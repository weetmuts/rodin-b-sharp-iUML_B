StatemachinesPackage
This is added:
	/**
	 * Statemachines extension ID, assigned to statemachines extensions to Event-B,
	 * as well as used by transformation to Event-B.
	 */
	String STATEMACHINES_EXTENSION_ID = "ac.soton.eventb.statemachines";


--------------------------

TransitionImpl

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public EventBElement getSourceContainer() {
		if (sourceContainer != null && sourceContainer.eIsProxy()) {
			InternalEObject oldSourceContainer = (InternalEObject)sourceContainer;
			sourceContainer = (EventBElement)eResolveProxy(oldSourceContainer);
			if (sourceContainer != oldSourceContainer) {
				if (eNotificationRequired())
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, StatemachinesPackage.TRANSITION__SOURCE_CONTAINER, oldSourceContainer, sourceContainer));
			}
		} else if (sourceContainer == null) {
			return getSource();
		}
		return sourceContainer;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public EventBElement getTargetContainer() {
		if (targetContainer != null && targetContainer.eIsProxy()) {
			InternalEObject oldTargetContainer = (InternalEObject)targetContainer;
			targetContainer = (EventBElement)eResolveProxy(oldTargetContainer);
			if (targetContainer != oldTargetContainer) {
				if (eNotificationRequired())
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, StatemachinesPackage.TRANSITION__TARGET_CONTAINER, oldTargetContainer, targetContainer));
			}
		} else if (targetContainer == null) {
			return getTarget();
		}
		return targetContainer;
	}

	


--------------------------
	
Statemachine

	/**
	 * The default value of the '{@link #getExtensionId() <em>Extension Id</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getExtensionId()
	 * @generated NOT
	 * @ordered
	 */
	protected static final String EXTENSION_ID_EDEFAULT = StatemachinesPackage.STATEMACHINES_EXTENSION_ID;

	/**
	 * The cached value of the '{@link #getExtensionId() <em>Extension Id</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getExtensionId()
	 * @generated NOT
	 * @ordered
	 */
	protected String extensionId = EXTENSION_ID_EDEFAULT+"."+EcoreUtil.generateUUID();


	/**
	 * <!-- begin-user-doc -->
	 * If selfName is still at the default (this), returns this_SMName
	 * Otherwise returns the value of selfName
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public String getSelfName() {
		return "this".equals(selfName)? "this_"+getName() : selfName;
	}


--------------------------
	
State (also similar in Statemachine)

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public String getName() {
		State refines = getRefines();
		if (refines != null){
			return refines.getName();
		} else return doGetName();
	}

	/**
	 * <!-- begin-user-doc -->
	 * Set the name attribute.
	 * Since : and . are used as delimiters in references which are formed from name, 
	 * these characters are not permitted and are changed automatically
	 * to ; and , respectively.
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public void setName(String newName) {
		if (newName == null) return;		
		String oldName = getName();
		name = newName.replaceAll("\\.", ",").replaceAll(":", ";");
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, StatemachinesPackage.STATE__NAME, oldName, name));
	}
	
	/**
	 * <!-- begin-user-doc -->
	 * On refines change also notify about name change.
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public void setRefines(State newRefines) {
		State oldRefines = refines;
		refines = newRefines;
		if (eNotificationRequired()) {
			eNotify(new ENotificationImpl(this, Notification.SET, StatemachinesPackage.STATE__REFINES, oldRefines, refines));
			eNotify(new ENotificationImpl(this, Notification.SET, StatemachinesPackage.STATE__NAME, oldRefines, refines));
		}
	}
	
	
	
--------------------------
In AbstractNodeImpl, Override getName to use internalID when a name has not been set.
This enables legacy models to continue to work in the new meta-model.

	
		/**
	 * <!-- begin-user-doc -->
	 * return the name (using doGetName()) if it is not null
	 * otherwise return the local id of this node (initialising it if necessary).
	 * This means that users do not have to bother with naming pseudo-states  (usually they are not visible anyway)
	 * unless they want prettier names (e.g. in text representations)
	 * 
	 * note: this method avoids using getInternalID since it will call back getName()
	 * 
	 * <!-- end-user-doc -->
	 * @custom
	 */
	@Override
	public String getName() {
		String name = doGetName();
		
		if ((name==null || name.length()==0) &&						// THIS IS A TEMPORARY MEASURE TO
				(internalId != null && internalId.length()>0)){		// SUPPORT LEGACY MODELS THAT USED
			return internalId;										// internalId FOR REFERENCING PSEUDO-STATES
		}
		
		return name;
	}
	
	
	
	--------------------------
	
	
--------------------------
	
StatemachinesValidator

populate all the Validate operations

--------------------------




CUSTOMISATIONS IN GENERATED DIAGRAM CODE
-----------------------------------------


Many of the edit.commands have their doExecuteWithResult method customised to automatically name the new element
E.g. For Any2CreateCommand  
(n.b. Any2CreateCommand is for nested statemachines. without the 2 - AnyCreateCommand - is for the root level canvas.
In fact these two classes are identical).

	/**
	 * @generated NOT
	 */
	protected CommandResult doExecuteWithResult(IProgressMonitor monitor,
			IAdaptable info) throws ExecutionException {
		Any newElement = StatemachinesFactory.eINSTANCE.createAny();

		Statemachine owner = (Statemachine) getElementToEdit();
		owner.getNodes().add(newElement);

		//+++++++++
		String name = NameUtils.getName( (Diagram) newElement.getContaining(DiagramsPackage.Literals.DIAGRAM))+
				"_"+newElement.eClass().getName().toLowerCase();
		name = NameUtils.getSafeName(newElement, name, owner, null);
		newElement.setName(name);
		//---------
		
		doConfigure(newElement, monitor, info);

		((CreateElementRequest) getRequest()).setNewElement(newElement);
		return CommandResult.newOKCommandResult(newElement);
	}

-----------------------------------------

Some Edit Parts have extra methods to provide hover over feedback.
E.G InvariantEditPart

	/////////// mouse-over feedback text ///////////	
	Label feedbackFigure=null;
	String feedbackText=null;;

	
	/*
	 * Provides mouse over feedback:
	 * Customised to  show the contents of the invariant
	 * @custom
	 */
	@Override
	public void showTargetFeedback(Request request) {
		super.showTargetFeedback(request);
		// the feedback layer figures do not receive mouse e
		if (feedbackText==null) {
			feedbackText = getMethodText();
			if (feedbackText.length()>0){
				feedbackFigure = new Label(feedbackText);
				feedbackFigure.setFont(new Font(null, "Arial", 12, SWT.NORMAL));
				Rectangle bounds = feedbackFigure.getTextBounds().getCopy().expand(10, 10);
				Point location = getFigure().getBounds().getLocation().translate(50, 0);			
				getFigure().translateToAbsolute(location);
				bounds.setLocation(location);
				feedbackFigure.setBounds(bounds);
				feedbackFigure.setForegroundColor(ColorConstants.darkGreen);  //tooltipForeground);
				feedbackFigure.setBackgroundColor(ColorConstants.lightGray); //tooltipBackground);
				feedbackFigure.setOpaque(true);
				//feedbackFigure.setBorder(new LineBorder());
				IFigure layer = getLayer(LayerConstants.FEEDBACK_LAYER);
				layer.add(feedbackFigure);
			}
		}
	}

	private String getMethodText() {
		Invariant invariant = (Invariant) resolveSemanticElement();
		String text = invariant.getName()+ (invariant.isTheorem()? "(THEOREM) :\n" : " :\n");
		text = text + indent(1,"",invariant.getPredicate());
		if (invariant.getComment()!=null && invariant.getComment().length()>0) {
			text = text + "\n"+ indent(2, "//", invariant.getComment());
		}
		return text;
	}
	
	private static String indent(int tabs, String prefix, String text){
		if (text==null || text.length()<1) return "";
		String indent = "";
		for (int i=0; i<tabs; i++){
			indent = indent+"\t";
		}
		indent = indent+prefix;
		return indent+text.replace("\n", "\n"+indent);
	}

	/* Erases mouse-over feedback.
	 * @custom
	 */
	@Override
	public void eraseTargetFeedback(Request request) {
		super.eraseTargetFeedback(request);
		if (request instanceof CreateConnectionRequest)
			return;
		if (getViewer()==null) {
			return;
		}
		IFigure layer = getLayer(LayerConstants.FEEDBACK_LAYER);
		if (layer != null && feedbackFigure != null
				&& feedbackFigure.getParent() != null) {
			layer.remove(feedbackFigure);
		}
		feedbackFigure = null;
		feedbackText = null;
	}
	
	
	