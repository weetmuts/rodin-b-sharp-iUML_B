StatemachinesPackage
This is added:
	/**
	 * Statemachines extension ID, assigned to statemachines extensions to Event-B,
	 * as well as used by transformation to Event-B.
	 */
	String STATEMACHINES_EXTENSION_ID = "ac.soton.eventb.statemachines";


--------------------------

TransitionImpl

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public EventBElement getSourceContainer() {
		if (sourceContainer != null && sourceContainer.eIsProxy()) {
			InternalEObject oldSourceContainer = (InternalEObject)sourceContainer;
			sourceContainer = (EventBElement)eResolveProxy(oldSourceContainer);
			if (sourceContainer != oldSourceContainer) {
				if (eNotificationRequired())
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, StatemachinesPackage.TRANSITION__SOURCE_CONTAINER, oldSourceContainer, sourceContainer));
			}
		} else if (sourceContainer == null) {
			return getSource();
		}
		return sourceContainer;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public EventBElement getTargetContainer() {
		if (targetContainer != null && targetContainer.eIsProxy()) {
			InternalEObject oldTargetContainer = (InternalEObject)targetContainer;
			targetContainer = (EventBElement)eResolveProxy(oldTargetContainer);
			if (targetContainer != oldTargetContainer) {
				if (eNotificationRequired())
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, StatemachinesPackage.TRANSITION__TARGET_CONTAINER, oldTargetContainer, targetContainer));
			}
		} else if (targetContainer == null) {
			return getTarget();
		}
		return targetContainer;
	}

	


--------------------------
	
Statemachine

	/**
	 * The default value of the '{@link #getExtensionId() <em>Extension Id</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getExtensionId()
	 * @generated NOT
	 * @ordered
	 */
	protected static final String EXTENSION_ID_EDEFAULT = StatemachinesPackage.STATEMACHINES_EXTENSION_ID;

	/**
	 * The cached value of the '{@link #getExtensionId() <em>Extension Id</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getExtensionId()
	 * @generated NOT
	 * @ordered
	 */
	protected String extensionId = EXTENSION_ID_EDEFAULT+"."+EcoreUtil.generateUUID();


	/**
	 * <!-- begin-user-doc -->
	 * If selfName is still at the default (this), returns this_SMName
	 * Otherwise returns the value of selfName
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public String getSelfName() {
		return "this".equals(selfName)? "this_"+getName() : selfName;
	}


--------------------------
	
State (also similar in Statemachine)

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public String getName() {
		State refines = getRefines();
		if (refines != null){
			return refines.getName();
		} else return doGetName();
	}

	/**
	 * <!-- begin-user-doc -->
	 * Set the name attribute.
	 * Since : and . are used as delimiters in references which are formed from name, 
	 * these characters are not permitted and are changed automatically
	 * to ; and , respectively.
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public void setName(String newName) {
		if (newName == null) return;		
		String oldName = getName();
		name = newName.replaceAll("\\.", ",").replaceAll(":", ";");
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, StatemachinesPackage.STATE__NAME, oldName, name));
	}
	
	/**
	 * <!-- begin-user-doc -->
	 * On refines change also notify about name change.
	 * <!-- end-user-doc -->
	 * @generated NOT
	 */
	public void setRefines(State newRefines) {
		State oldRefines = refines;
		refines = newRefines;
		if (eNotificationRequired()) {
			eNotify(new ENotificationImpl(this, Notification.SET, StatemachinesPackage.STATE__REFINES, oldRefines, refines));
			eNotify(new ENotificationImpl(this, Notification.SET, StatemachinesPackage.STATE__NAME, oldRefines, refines));
		}
	}
	
	
	
--------------------------
In AbstractNodeImpl, Override getName to use internalID when a name has not been set.
This enables legacy models to continue to work in the new meta-model.

	
		/**
	 * <!-- begin-user-doc -->
	 * return the name (using doGetName()) if it is not null
	 * otherwise return the local id of this node (initialising it if necessary).
	 * This means that users do not have to bother with naming pseudo-states  (usually they are not visible anyway)
	 * unless they want prettier names (e.g. in text representations)
	 * 
	 * note: this method avoids using getInternalID since it will call back getName()
	 * 
	 * <!-- end-user-doc -->
	 * @custom
	 */
	@Override
	public String getName() {
		String name = doGetName();
		
		if ((name==null || name.length()==0) &&						// THIS IS A TEMPORARY MEASURE TO
				(internalId != null && internalId.length()>0)){		// SUPPORT LEGACY MODELS THAT USED
			return internalId;										// internalId FOR REFERENCING PSEUDO-STATES
		}
		
		return name;
	}
	
	
	
	--------------------------
	
	
--------------------------
	
StatemachinesValidator

populate all the Validate operations

--------------------------




CUSTOMISATIONS IN GENERATED DIAGRAM CODE
-------------------------------------------------------------------------------------
These should possibly be moved to the custom templates before the next re-generation
-------------------------------------------------------------------------------------

Many of the edit.commands have their doExecuteWithResult method customised to automatically name the new element
E.g. For Any2CreateCommand  
(n.b. Any2CreateCommand is for nested statemachines. without the 2 - AnyCreateCommand - is for the root level canvas.
In fact these two classes are identical).

	/**
	 * @generated NOT
	 */
	protected CommandResult doExecuteWithResult(IProgressMonitor monitor,
			IAdaptable info) throws ExecutionException {
		Any newElement = StatemachinesFactory.eINSTANCE.createAny();

		Statemachine owner = (Statemachine) getElementToEdit();
		owner.getNodes().add(newElement);

		//+++++++++
		String name = NameUtils.getName( (Diagram) newElement.getContaining(DiagramsPackage.Literals.DIAGRAM))+
				"_"+newElement.eClass().getName().toLowerCase();
		name = NameUtils.getSafeName(newElement, name, owner, null);
		newElement.setName(name);
		//---------
		
		doConfigure(newElement, monitor, info);

		((CreateElementRequest) getRequest()).setNewElement(newElement);
		return CommandResult.newOKCommandResult(newElement);
	}

-----------------------------------------

Some Edit Parts have extra methods to provide hover over feedback.
E.G InvariantEditPart

	/////////// mouse-over feedback text ///////////	
	Label feedbackFigure=null;
	String feedbackText=null;;

	
	/*
	 * Provides mouse over feedback:
	 * Customised to  show the contents of the invariant
	 * @custom
	 */
	@Override
	public void showTargetFeedback(Request request) {
		super.showTargetFeedback(request);
		// the feedback layer figures do not receive mouse e
		if (feedbackText==null) {
			feedbackText = getMethodText();
			if (feedbackText.length()>0){
				feedbackFigure = new Label(feedbackText);
				feedbackFigure.setFont(new Font(null, "Arial", 12, SWT.NORMAL));
				Rectangle bounds = feedbackFigure.getTextBounds().getCopy().expand(10, 10);
				Point location = getFigure().getBounds().getLocation().translate(50, 0);			
				getFigure().translateToAbsolute(location);
				bounds.setLocation(location);
				feedbackFigure.setBounds(bounds);
				feedbackFigure.setForegroundColor(ColorConstants.darkGreen);  //tooltipForeground);
				feedbackFigure.setBackgroundColor(ColorConstants.lightGray); //tooltipBackground);
				feedbackFigure.setOpaque(true);
				//feedbackFigure.setBorder(new LineBorder());
				IFigure layer = getLayer(LayerConstants.FEEDBACK_LAYER);
				layer.add(feedbackFigure);
			}
		}
	}

	private String getMethodText() {
		Invariant invariant = (Invariant) resolveSemanticElement();
		String text = invariant.getName()+ (invariant.isTheorem()? "(THEOREM) :\n" : " :\n");
		text = text + indent(1,"",invariant.getPredicate());
		if (invariant.getComment()!=null && invariant.getComment().length()>0) {
			text = text + "\n"+ indent(2, "//", invariant.getComment());
		}
		return text;
	}
	
	private static String indent(int tabs, String prefix, String text){
		if (text==null || text.length()<1) return "";
		String indent = "";
		for (int i=0; i<tabs; i++){
			indent = indent+"\t";
		}
		indent = indent+prefix;
		return indent+text.replace("\n", "\n"+indent);
	}

	/* Erases mouse-over feedback.
	 * @custom
	 */
	@Override
	public void eraseTargetFeedback(Request request) {
		super.eraseTargetFeedback(request);
		if (request instanceof CreateConnectionRequest)
			return;
		if (getViewer()==null) {
			return;
		}
		IFigure layer = getLayer(LayerConstants.FEEDBACK_LAYER);
		if (layer != null && feedbackFigure != null
				&& feedbackFigure.getParent() != null) {
			layer.remove(feedbackFigure);
		}
		feedbackFigure = null;
		feedbackText = null;
	}
	
----------------------------------

Validate action did not work when fired from the property sheet
Changed ValidatAction in ac.soton...part to get the active editor instead of the active part
	/**
	 * @generated NOT
	 */
	public void run() {
		IWorkbenchPart workbenchPart = page.getActiveEditor();	
	...

-----------------------------------
re targetting or re-sourcing a transition (if done outside of diagram editors, such as by Rose or refactoring) would 
not delete the old view from the layout resulting in both the old edge and the new edge being drawn.
to fix this, RootStatemachineCanonicalEditPolicy$shouldDeleteView(View view) is modified to check that the 
element's source and target match the edge's 


	
	/**
	 * Return <tt>true</tt> if this editpolicy should try and delete the
	 * supplied view; otherwise <tt>false<tt>. 
	 *  
	 * For transitions, true is returned if the source or target of the view do not represent the semantic source or target resp.
	 * (i.e. if the transition has been moved to a different source or target state)
	 * 
	 * Otherwise the default behavior is returned
	 * 
	 * @CUSTOM
	 */
	protected boolean shouldDeleteView(View view) {
		EObject sel = ViewUtil.resolveSemanticElement(view);
		if (sel instanceof Transition && view instanceof Edge){
			Transition tr = (Transition)sel;
			Edge ed = (Edge)view;
			if (ed.getSource().getElement()!=tr.getSource() || ed.getTarget().getElement()!=tr.getTarget() ){
				return true;
			}			
		}
		return super.shouldDeleteView(view) ;
	}
	
	
For Refactoring
-----------------------------------------

in StatemachinesDiagramEditor all this has been added 
	
///////////////////////////////////////////////////////////////////////////////////////
	/// The following methods have been overridden to 
	// a) save on de-activation to avoid synch problems between several editors
	// b) provide change recording
	////////////////////////////////////////////////////////////////////////////////
	
	
	@Override
	public void setInput(IEditorInput input) {
		super.setInput(input);
		getSite().getPage().addPartListener(this);
	}

	@Override
	public void dispose() {
		ecr.disposeChangeRecorder();
		super.dispose();
		getSite().getPage().removePartListener(this);
	}

	private boolean deactivating = false;

	/**
	 * Saves editor if it is deactivated.
	 * 
	 * @param part
	 */
	@Override
	public void partDeactivated(IWorkbenchPart part) {
		if (part == this) {
			deactivating = true;
		}
	}

	@Override
	public void partActivated(IWorkbenchPart part) {
		if (deactivating == true) {
			if (part != this
					&& isDirty()
					&& !(part instanceof PropertySheet)
					&& !animating()		) {
				doSave(new NullProgressMonitor());
			}
			if (part == this) {
				deactivating = false;
			}
		}else if (part==this){
			
		}
	}
	
	
	/*
	 * checks whether the Statemachine of this diagram is being animated
	 */
	private boolean animating(){
		Statemachine sm = (Statemachine) this.getDiagram().getElement();
		EList<EObject> states = sm.getAllContained(StatemachinesPackage.Literals.STATE, true);
		for (EObject eo : states){
			if (eo instanceof State && ((State)eo).isActive()) return true;
		}
		EList<EObject> transitions = sm.getAllContained(StatemachinesPackage.Literals.TRANSITION, true);
		for (EObject eo : transitions){
			if (eo instanceof Transition 
					&& ((Transition)eo).getOperations()!=null
					&& ((Transition)eo).getOperations().size()>0) return true;
		}
		return false;
	}

	@Override
	public void partBroughtToTop(IWorkbenchPart part) {

	}
	
///////////////////changeRecording///////////////////

	@Override
	public void partClosed(IWorkbenchPart part) {
		System.out.println("closing");
		if (ecr!=null) ecr.disposeChangeRecorder();
		System.out.println("closed and disposed");
	}

	@Override
	public void partOpened(IWorkbenchPart part) {
		System.out.println("opening");
		EObject diagramElement = this.getDiagram().getElement();
		if (diagramElement instanceof EventBElement){
			EventBObject component = ((EventBElement)diagramElement).getContaining(CorePackage.Literals.EVENT_BNAMED_COMMENTED_COMPONENT_ELEMENT);
			ecr=new Recorder((EventBNamedCommentedComponentElement)component);
			ecr.resumeRecording();
		}
		System.out.println("opened and recording");
	}
	
	@Override
	public void doSave(IProgressMonitor progressMonitor) {
		System.out.println("saving");
		if (ecr!=null) ecr.saveChanges();
		super.doSave(progressMonitor);
		if (ecr!=null) ecr.resumeRecording();
		System.out.println("saved and still recording");
	}
	
	private Recorder ecr=null;