
CUSTOMISATIONS IN GENERATED DIAGRAM CODE
-------------------------------------------------------------------------------------
These should possibly be moved to the custom templates before the next re-generation
-------------------------------------------------------------------------------------

Many of the edit.commands have their doExecuteWithResult method customised to automatically name the new element
E.g. For Any2CreateCommand  
(n.b. Any2CreateCommand is for nested statemachines. without the 2 - AnyCreateCommand - is for the root level canvas.
In fact these two classes are identical).

	/**
	 * @generated NOT
	 */
	protected CommandResult doExecuteWithResult(IProgressMonitor monitor,
			IAdaptable info) throws ExecutionException {
		Any newElement = StatemachinesFactory.eINSTANCE.createAny();

		Statemachine owner = (Statemachine) getElementToEdit();
		owner.getNodes().add(newElement);

		//+++++++++
		String name = NameUtils.getName( (Diagram) newElement.getContaining(DiagramsPackage.Literals.DIAGRAM))+
				"_"+newElement.eClass().getName().toLowerCase();
		name = NameUtils.getSafeName(newElement, name, owner, null);
		newElement.setName(name);
		//---------
		
		doConfigure(newElement, monitor, info);

		((CreateElementRequest) getRequest()).setNewElement(newElement);
		return CommandResult.newOKCommandResult(newElement);
	}

-----------------------------------------

Some Edit Parts have extra methods to provide hover over feedback.
E.G InvariantEditPart

	/////////// mouse-over feedback text ///////////	
	Label feedbackFigure=null;
	String feedbackText=null;;

	
	/*
	 * Provides mouse over feedback:
	 * Customised to  show the contents of the invariant
	 * @custom
	 */
	@Override
	public void showTargetFeedback(Request request) {
		super.showTargetFeedback(request);
		// the feedback layer figures do not receive mouse e
		if (feedbackText==null) {
			feedbackText = getMethodText();
			if (feedbackText.length()>0){
				feedbackFigure = new Label(feedbackText);
				feedbackFigure.setFont(new Font(null, "Arial", 12, SWT.NORMAL));
				Rectangle bounds = feedbackFigure.getTextBounds().getCopy().expand(10, 10);
				Point location = getFigure().getBounds().getLocation().translate(50, 0);			
				getFigure().translateToAbsolute(location);
				bounds.setLocation(location);
				feedbackFigure.setBounds(bounds);
				feedbackFigure.setForegroundColor(ColorConstants.darkGreen);  //tooltipForeground);
				feedbackFigure.setBackgroundColor(ColorConstants.lightGray); //tooltipBackground);
				feedbackFigure.setOpaque(true);
				//feedbackFigure.setBorder(new LineBorder());
				IFigure layer = getLayer(LayerConstants.FEEDBACK_LAYER);
				layer.add(feedbackFigure);
			}
		}
	}

	private String getMethodText() {
		Invariant invariant = (Invariant) resolveSemanticElement();
		String text = invariant.getName()+ (invariant.isTheorem()? "(THEOREM) :\n" : " :\n");
		text = text + indent(1,"",invariant.getPredicate());
		if (invariant.getComment()!=null && invariant.getComment().length()>0) {
			text = text + "\n"+ indent(2, "//", invariant.getComment());
		}
		return text;
	}
	
	private static String indent(int tabs, String prefix, String text){
		if (text==null || text.length()<1) return "";
		String indent = "";
		for (int i=0; i<tabs; i++){
			indent = indent+"\t";
		}
		indent = indent+prefix;
		return indent+text.replace("\n", "\n"+indent);
	}

	/* Erases mouse-over feedback.
	 * @custom
	 */
	@Override
	public void eraseTargetFeedback(Request request) {
		super.eraseTargetFeedback(request);
		if (request instanceof CreateConnectionRequest)
			return;
		if (getViewer()==null) {
			return;
		}
		IFigure layer = getLayer(LayerConstants.FEEDBACK_LAYER);
		if (layer != null && feedbackFigure != null
				&& feedbackFigure.getParent() != null) {
			layer.remove(feedbackFigure);
		}
		feedbackFigure = null;
		feedbackText = null;
	}
	
----------------------------------

Validate action did not work when fired from the property sheet
Changed ValidatAction in ac.soton...part to get the active editor instead of the active part
	/**
	 * @generated NOT
	 */
	public void run() {
		IWorkbenchPart workbenchPart = page.getActiveEditor();	
	...

-----------------------------------
re targetting or re-sourcing a transition (if done outside of diagram editors, such as by Rose or refactoring) would 
not delete the old view from the layout resulting in both the old edge and the new edge being drawn.
to fix this, RootStatemachineCanonicalEditPolicy$shouldDeleteView(View view) is modified to check that the 
element's source and target match the edge's 


	
	/**
	 * Return <tt>true</tt> if this editpolicy should try and delete the
	 * supplied view; otherwise <tt>false<tt>. 
	 *  
	 * For transitions, true is returned if the source or target of the view do not represent the semantic source or target resp.
	 * (i.e. if the transition has been moved to a different source or target state)
	 * 
	 * Otherwise the default behavior is returned
	 * 
	 * @CUSTOM
	 */
	protected boolean shouldDeleteView(View view) {
		EObject sel = ViewUtil.resolveSemanticElement(view);
		if (sel instanceof Transition && view instanceof Edge){
			Transition tr = (Transition)sel;
			Edge ed = (Edge)view;
			if (ed.getSource().getElement()!=tr.getSource() || ed.getTarget().getElement()!=tr.getTarget() ){
				return true;
			}			
		}
		return super.shouldDeleteView(view) ;
	}
	
	
For Refactoring
-----------------------------------------

in StatemachinesDiagramEditor all this has been added 
	
///////////////////////////////////////////////////////////////////////////////////////
	/// The following methods have been overridden to 
	// a) save on de-activation to avoid synch problems between several editors
	// b) provide change recording
	////////////////////////////////////////////////////////////////////////////////
	
	
	@Override
	public void setInput(IEditorInput input) {
		super.setInput(input);
		getSite().getPage().addPartListener(this);
	}

	@Override
	public void dispose() {
		ecr.disposeChangeRecorder();
		super.dispose();
		getSite().getPage().removePartListener(this);
	}

	private boolean deactivating = false;

	/**
	 * Saves editor if it is deactivated.
	 * 
	 * @param part
	 */
	@Override
	public void partDeactivated(IWorkbenchPart part) {
		if (part == this) {
			deactivating = true;
		}
	}

	@Override
	public void partActivated(IWorkbenchPart part) {
		if (deactivating == true) {
			if (part != this
					&& isDirty()
					&& !(part instanceof PropertySheet)
					&& !animating()		) {
				doSave(new NullProgressMonitor());
			}
			if (part == this) {
				deactivating = false;
			}
		}else if (part==this){
			
		}
	}
	
	
	/*
	 * checks whether the Statemachine of this diagram is being animated
	 */
	private boolean animating(){
		Statemachine sm = (Statemachine) this.getDiagram().getElement();
		EList<EObject> states = sm.getAllContained(StatemachinesPackage.Literals.STATE, true);
		for (EObject eo : states){
			if (eo instanceof State && ((State)eo).isActive()) return true;
		}
		EList<EObject> transitions = sm.getAllContained(StatemachinesPackage.Literals.TRANSITION, true);
		for (EObject eo : transitions){
			if (eo instanceof Transition 
					&& ((Transition)eo).getOperations()!=null
					&& ((Transition)eo).getOperations().size()>0) return true;
		}
		return false;
	}

	@Override
	public void partBroughtToTop(IWorkbenchPart part) {

	}
	
///////////////////changeRecording///////////////////

	@Override
	public void partClosed(IWorkbenchPart part) {
		System.out.println("closing");
		if (ecr!=null) ecr.disposeChangeRecorder();
		System.out.println("closed and disposed");
	}

	@Override
	public void partOpened(IWorkbenchPart part) {
		System.out.println("opening");
		EObject diagramElement = this.getDiagram().getElement();
		if (diagramElement instanceof EventBElement){
			EventBObject component = ((EventBElement)diagramElement).getContaining(CorePackage.Literals.EVENT_BNAMED_COMMENTED_COMPONENT_ELEMENT);
			ecr=new Recorder((EventBNamedCommentedComponentElement)component);
			ecr.resumeRecording();
		}
		System.out.println("opened and recording");
	}
	
	@Override
	public void doSave(IProgressMonitor progressMonitor) {
		System.out.println("saving");
		if (ecr!=null) ecr.saveChanges();
		super.doSave(progressMonitor);
		if (ecr!=null) ecr.resumeRecording();
		System.out.println("saved and still recording");
	}
	
	private Recorder ecr=null;